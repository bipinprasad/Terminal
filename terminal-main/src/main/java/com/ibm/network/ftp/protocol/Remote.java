/************************************************************************
  This software is subject to the terms of the IBM alphaBeans with Source 
  License Agreement available at 
  www.software.ibm.com/developer/alphabeans/source/license.html.
  
  Copyright (c) 1999 IBM Corporation and others. All rights reserved. 
  
  You must accept the terms of that agreement to use this software.
 *************************************************************************/

/* @(#) Remote.java        Ver 1.12    
 *
 * Copyright (c) 1998 International Business Machines.
 * All Rights Reserved.
 *
 * Author : Rajesh Singh
 * Last Modified : 11,August,1998
 *
 * Purpose : Defines class Remote.
 *
 *
 * Revision History 
 * ======== ======= 
 *
 * Date        By            Description
 * ----        --            -----------
 * ????     Rajesh Singh    Initial Release.
 * 11,Aug,98 Sunanda Bera   Added this file header.
 * 11,Aug,98 Sunanda Bera   Replaced all command creation by a factory method. This enabled
 *                          the ease of a common termination ( <CRLF> ) for all commands. This
 *                          was done to solve the bug raised in ITT PTR -- 01426
 * 11,Aug,98 Sunanda Bera   Replaced most of the command execution sequence of createCommand, printText,
 *                          controlOutputStream.println and checkResponse by a single method executeCommand.
 *                          This was done to ease further maintenance of this code.
 * 11,Aug,98 Sunanda Bera   Added a comment to every command execution to record the possible replies to that
 *                          command. This was done to ease further maintenance of this code. Note that no analysis
 *                          of replies is not done in the code.
 * 11,Aug,98 Sunanda Bera   Changed method configureSocks. Passive mode is now set when the socks server is configured.
 *                          Obviously, one cannot act in an active mode behind a firewall. Previously, a trial and error
 *                          method was used to find whether one should act in passive mode or not. This worked fine for
 *                          servers which replied with error on PORT command when one is behind a socks firewall. But for
 *                          servers which do not match IP in PORT command ( behind the firewall the IP from which the connection
 *                          is made is that of the socks server and not that of the client ), this caused a problem.
 *                          Also changed PASSIVE from a static property to an instance variable. There is no reason why it
 *                          should be a class variable.
 *                          This also removes the bug mentioned in ITT PTR -- 01427
 * 11,Aug,98 Sunanda Bera   Change in method login. It is now possible to login to servers which do not have security check
 *                          for certain users.
 */
package com.ibm.network.ftp.protocol;

import java.net.*;
import java.io.*;
import java.util.*;
import com.ibm.network.ftp.FileInfo;

/**
 * This class was generated by a SmartGuide.
 * 
 */
class Remote extends Protocol {
	private FTPProtocol parent = null;
	private String hostName = null;
	//private String userName = null;
	private boolean PASSIVE = false;
	private int passivePort;
	public String type;
	private String remoteCurrentDir = null;
	// private static Remote instance=null;
	private java.util.Vector<FileInfo> remoteFileList = null;

	private static final int POSITIVE_PRELIMINARY_REPLY = 1;
	private static final int POSITIVE_COMPLETION_REPLY = 2;
	private static final int POSITIVE_INTERMEDIATE_REPLY = 3;
	//private static final int TRANSIENT_NEGATIVE_REPLY = 4;
	//private static final int PERMANENT_NEGATIVE_REPLY = 5;

	private static final int IDLE = 0;
	private static final int CONNECTED = 1;

	private int state = IDLE;

	// private static Socket controlConnectionSocket=null;
	// private static DataInputStream controlInputStream=null;
	// private static PrintStream controlOutputStream=null;
	private Socket controlConnectionSocket = null;
	private DataInputStream controlInputStream = null;
	private PrintStream controlOutputStream = null;

	/*********** Changed in FTP1.03 ************************/
	// This variable holds the remote system type by default
	// it is UNIX. At present support for VM will be provided
	private String serverOS = new String("UNIX");

	/************** Changed in FTP1.06 dated9/3/98 *********/
	// This change was required for multihomed machines
	private InetAddress localHost = null;

	/**
	 * This method was created by a SmartGuide.
	 */
	Remote(FTPProtocol parent) {
		if (parent != null) {
			this.parent = parent;
		} else {
		}
	}

	/**
	 * This method was created by a SmartGuide.
	 */
	public void abort() {
		int replycode;
		//String command;
		if (state == CONNECTED) {
			replycode = executeCommand("ABOR", null);
			if (replycode == POSITIVE_COMPLETION_REPLY) {
				// If the change directory is successful then
				// the new list should be sent to the User Interface
				printText("Abort attempt successful\r\n");
				return;
			}
			return;
		} else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
			return;
		}
		return;
	}

	/**
	 * This method was created by a SmartGuide.
	 */
	public void noop() {
		int replycode;
		//String command;
		if (state == CONNECTED) {
			replycode = executeCommand("NOOP", null);
			return;
		} else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
			return;
		}
		return;
	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param serSocket
	 *            java.net.ServerSocket
	 */
	private String calculatePort(java.net.ServerSocket serverSocket) {
		String dataPortString;
		int dataPort;
		//InetAddress localAddr;
		InetAddress localIpAddress;
		//InetAddress[] address;
		// read the port at which the ServerSocket is connected
		dataPort = serverSocket.getLocalPort();

		try {
			// get the local host
			localIpAddress = InetAddress.getLocalHost();
		}// end of try
		catch (UnknownHostException e) {
			// Can't find out the local host address
			return ("");
		}// end of catch
			// Get the ip address
		byte[] addressBytes = localIpAddress.getAddress();
		// tell server what port we are listening on
		short addressShorts[] = new short[4];
		// problem: bytes greater than 127 are printed as negative numbers
		for (int i = 0; i <= 3; i++) {
			addressShorts[i] = addressBytes[i];
			if (addressShorts[i] < 0) {
				addressShorts[i] += 256;
			}// end of if
		}// end of for
		dataPortString = new String(addressShorts[0] + "," + addressShorts[1]
				+ "," + addressShorts[2] + "," + addressShorts[3] + ","
				+ ((dataPort & 0xff00) >> 8) + "," + (dataPort & 0x00ff));

		return (dataPortString);
	}

	/**
	 * changeDir method comment.
	 */
	public void changeDir(String newDir) {
		int replycode;
		//String command;
		if (state == CONNECTED) {
			replycode = executeCommand("CWD", newDir);
			if (replycode == POSITIVE_COMPLETION_REPLY) {
				// If the change directory is successful then
				// the new list should be sent to the User Interface

				return;
			}
		} else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
			return;
		}

		return;
	}

	// CF -- Sunanda Bera 9 July 1988
	// added this method to check whether the reply is the last line
	// of reply from the server
	/**
	 * Last line of reply ?
	 */
	private boolean endOfReply(String reply) {
		boolean result = false;
		if (reply.length() >= 4 && Character.isDigit(reply.charAt(0))
				&& Character.isDigit(reply.charAt(1))
				&& Character.isDigit(reply.charAt(2)) && reply.charAt(3) == ' ')
			result = true;
		return result;

	}// endOfReply()
		// CF

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @return int
	 */
	public int checkResponse() {

		String reply;

		try {
			do {
				reply = controlInputStream.readLine();
				printText(reply + "\r\n");

			}
			// Continue reading till the first three characters
			// are digits followed by blank space. The three
			// digits are reply code from FTP server.
			// CF -- Sunanda Bera 9 July 1998
			// changed to avoid exception when a multiline reply from server
			// contains
			// line of length less than four characters.
			// OLD CODE
			/*
			 * while(!(Character.isDigit(reply.charAt(0)) &&
			 * Character.isDigit(reply.charAt(1)) &&
			 * Character.isDigit(reply.charAt(2)) && reply.charAt(3) == ' '));
			 */
			// NEW CODE
			while (!endOfReply(reply));
			// CF
		} catch (IOException e) {
			printText("ERROR: Error reading from  the controlconnection! "
					+ "\r\n");
			/*************** Changed in FTP1.03 Dated 22/01/98 ************/
			// IF there is some Error in control connection then the remote
			// directory and fileList should be removed beacause it cannot be
			// restarted.
			this.remoteCurrentDir = new String("");
			// if the vector is not empty, remove all elements
			if (this.remoteFileList != null) {
				if (!(this.remoteFileList.isEmpty())) {
					this.remoteFileList.removeAllElements();
				}// end of if
			}// end of outer if
			/**************** Change Over ******************/
			return (0);

		} catch (Exception e) {
			printText("Error while connecting\r\n");
			return (0);
		}

		return (Integer.parseInt(reply.substring(0, 1)));
	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param socksHost
	 *            java.lang.String
	 * @param port
	 *            int
	 */
	public void configureSocks(java.lang.String socksHost, String port) {
		Properties properties = new Properties(System.getProperties());
		if (socksHost == null || port == null) {
			properties.remove("socksProxyHost");
			properties.remove("socksProxyPort");
			setPassive(false);
			// remove any socks property
		} else {
			// Get the default properties

			properties.put("socksProxyHost", socksHost);
			properties.put("socksProxyPort", port);
			// set the new properties back
			System.setProperties(properties);
			setPassive(true);
			// CF -- Sunanda Bera 9 July 1998
			// changed to reflect proper status message when socks is set
			printText("Socks server set with hostname = " + socksHost
					+ " and port = " + port + " \r\n");
			// CF
			return;
		}
	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param hostName
	 *            java.lang.String
	 */
	public void connect(java.lang.String hostName) {

		// Check whether protocol is already connected
		if (state == CONNECTED) {
			// Close the connection if already connected.
			this.disconnect();
		}
		try {

			// set host name variable for remote Protocol
			this.hostName = new String(hostName);
			// Open a socket connection for control connection at
			// port number 21.
			controlConnectionSocket = new Socket(hostName, 21); // ftp port

			/************* Changed in FTP1.06 dated 9/3/98 **************/
			// For multihomed machines local address should be known for
			// creating server sockets
			localHost = controlConnectionSocket.getLocalAddress();
			/************* End of Change *******************************/

			// Get a handle to the input stream and outputstream
			// for the socket connection.
			controlInputStream = new DataInputStream(
					controlConnectionSocket.getInputStream());
			controlOutputStream = new PrintStream(
					controlConnectionSocket.getOutputStream());
			state = CONNECTED;
			/******************* Changed on 13/02/98 ***************/
			// Check the response for the initial connection attempt.
			checkResponse();
			/******************* End of Change *********************/
		} catch (UnknownHostException e) {
			printText("ERROR Unkown host: " + hostName + "\r\n");
			return;
		} catch (IOException e) {
			printText("ERROR Could not get input/output stream for: "
					+ hostName + "\r\n");
			return;
		}
		return;
	}

	/**
	 * deleteDir method comment.
	 */
	public void deleteDir(String dirName) {
		if (state == CONNECTED) {
			executeCommand("RMD", dirName);
			return;
			// REPLYCODECHECK
			// 250
			// 500, 501, 502, 421, 530, 550
		} else if (state == IDLE) {
			printText(" You are not connected to any server \r\n");
			return;
		}
	}

	/**
	 * deleteFile method comment.
	 */
	public void deleteFile(String fileName) {
		int replycode;
		//String command;
		if (state == CONNECTED) {
			replycode = executeCommand("DELE", fileName);
			// REPLYCODECHECK
			// 250
			// 450, 550
			// 500, 501, 502, 421, 530, 550
		} else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
			return;
		}
	}

	/**
	 * This method was created by a SmartGuide.
	 */
	public synchronized void disconnect() {
		// System.out.println("In disconnect "+Thread.activeCount());

		// if(!loginLock){

		if (state == CONNECTED) {
			try {
				// Send the quit command
				int result = executeCommand("QUIT", null);
				// REPLYCODECHECK
				// 221
				// 500
				controlOutputStream.close();
				controlInputStream.close();
				controlConnectionSocket.close();
				state = IDLE;
				this.remoteCurrentDir = new String("");
				// if the vector is not empty, remove all elements
				if (this.remoteFileList != null) {
					if (!(this.remoteFileList.isEmpty())) {
						this.remoteFileList.removeAllElements();
					}// end of if
				}// end of outer if
					// this.setPassive(false);
				/******* Changed in FTP1.03 Dated 22/01/98 *******/
				// After disconnecting the serverOS should be set to default
				serverOS = "UNIX";
				/******* Change Over ****************************/
			} catch (IOException e) {

				printText("ERR I/O failed while closing connection!\r\n");
				/*********************** Changed in FTP1.03 Dated 22/01/98 ****/
				serverOS = "UNIX";
				// this.setPassive(false);
				/******************* Change Over ***************************/
				return;
			}
		}// end of if for connected
		else if (state == IDLE) {
			printText("You are not connected to any FTP server \r\n");
			return;
		}
		return;
		// } //end of if for loginLock
	}

	/**
	 * fileList method comment.
	 */
	public java.util.Vector<FileInfo> fileList() {
		FileInfo fileInfo;
		Vector<FileInfo> fileList = null;
		//String command;
		ServerSocket serverSocket = null;
		Socket clientSocket = null;
		int replycode;
		if (state == IDLE) {
			printText("ERROR: You are not connected to any FTP server, cannot list files \r\n");
			// return the null vector.
			return (fileList);
		}// end of if
		if (PASSIVE == false) {
			try {
				// Create a server socket for the data connection to receive
				// file list
				serverSocket = new ServerSocket(0, 50, localHost);
			}// end of try
			catch (IOException e) {
				printText("ERROR: Could not get I/O for the server socket: "
						+ serverSocket.getLocalPort() + ", " + e + "\r\n");
				return (fileList);
			}

			// Inform the FTP server of the port at which the server
			// for data connection is listening.
			setDataPort(serverSocket);

			replycode = executeCommand("LIST", null);
			// REPLYCODECHECK
			// 125, 150
			// 226, 250
			// 425, 426, 451
			// 450
			// 500, 501, 502, 421, 530
			if (replycode == POSITIVE_PRELIMINARY_REPLY) {
				// Get a data socket from the server socket that we
				// openend previously.
				Socket dataSocket = null;
				try {
					dataSocket = serverSocket.accept();
				}// end of try
				catch (IOException e) {
					printText("ERROR: Unable to get data socket from serversocket: "
							+ serverSocket.getLocalPort() + ", " + e + "\r\n");
					return (fileList);
				}// end of catch
				try {
					// Get a hndle to inputstream of the data socket
					// to read the data of the file list.
					DataInputStream dataInputStream = new DataInputStream(
							dataSocket.getInputStream());
					// Create the vector which will store all the fileInfo
					// fileList=new Vector();
					fileList = setFileListDescription(dataInputStream, serverOS);
					/*********** Changed in FTP1.03 Dated 21/01/98 ************/
					dataInputStream.close();
					replycode = checkResponse();
					/************* Change OVER *******************************/
					// Close datainputstream and data socket
					dataSocket.close();
					// return fileList;
				}// end of try
				catch (IOException e) {
					printText("ERROR " + e.toString() + "\r\n");

					return (fileList);
				}// end of catch
			}// end of if that checks for positive preliminary reply
			else {
				try {
					serverSocket.close();
				}// end of try
				catch (IOException e) {
					printText("ERROR: " + e.toString() + "\r\n");
					return fileList;
				}// end of catch
				printText("ERROR: Could not get file list\r\n");
				printText("Trying to list files in PASSIVE mode \n"
						+ "This might take some time\r\n");
				// set to passive mode
				this.setPassive(true);
				// try to list again in passive mode
				this.fileList();
				return fileList;
			}// end of else
		}
		// end of if that checks for passive
		else if (PASSIVE = true) {
			this.passive();

			try {
				// Create a server socket for the data connection to receive
				// file list
				clientSocket = new Socket(this.hostName, passivePort);
			}// end of try
			catch (Exception e) {
				printText("ERROR: Could not get I/O for the data socket: "
						+ ", " + e + "\r\n");
				return (fileList);
			}

			replycode = executeCommand("LIST", null);
			// REPLYCODECHECK
			// 125, 150
			// 226, 250
			// 425, 426, 451
			// 450
			// 500, 501, 502, 421, 530

			if (replycode == POSITIVE_PRELIMINARY_REPLY) {
				// Get a data socket from the server socket that we
				// openend previously.

				try {
					// Get a hndle to inputstream of the data socket
					// to read the data of the file list.
					DataInputStream dataInputStream = new DataInputStream(
							clientSocket.getInputStream());
					fileList = setFileListDescription(dataInputStream, serverOS);

					// Close datainputstream and data socket
					dataInputStream.close();
					replycode = checkResponse();

					clientSocket.close();
					// return fileList;
				}// end of try
				catch (IOException e) {
					printText("ERROR " + e.toString() + "\r\n");
					return (fileList);
				}// end of catch
			}// end of if that checks for positive preliminary reply
			else {
				try {
					clientSocket.close();
				}// end of try
				catch (IOException e) {
					printText("ERROR: " + e.toString() + "\r\n");
					return fileList;
				}// end of catch
				printText("ERROR: Could not get file list\r\n");
				return fileList;
			}// end of else

		}

		this.remoteFileList = fileList;
		return fileList;
	}

	/**
	 * getCurrentDir method comment.
	 */
	public String getCurrentDir() {
		int count;
		//int replycode;
		String command = null;
		String reply = null;
		String tempString = null;
		String currentDir = null;
		StringTokenizer stoken;

		if (state == CONNECTED) {
			command = createCommand("PWD", null);
			controlOutputStream.print(command);
			printText(command);
			try {
				do {
					reply = controlInputStream.readLine();
					printText(reply + "\r\n");
				} while (!endOfReply(reply));
			} catch (IOException e) {
				printText("ERROR: Error reading reply from the controlConnection\r\n");
				return ("");
			}
			// REPLYCODECHECK
			// 257
			// 500, 501, 502, 421, 550
			// The command if successful will have the directory
			// name in the second word enclosed in " ".
			// Hence first we have to parse using space as token
			// and then remove the enclosing ".

			stoken = new StringTokenizer(reply);
			count = 0;
			while (stoken.hasMoreTokens() && (currentDir == null)) {
				tempString = stoken.nextToken();
				count++;
				if (count == 2) {
					currentDir = new String(tempString.substring(1,
							tempString.length() - 1));
					break;
				}
			}
		}

		this.remoteCurrentDir = currentDir;
		return (currentDir);
	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param fileName
	 *            java.lang.String
	 */

	/*
	 * public void getFile(java.lang.String fileName) { ServerSocket
	 * serverSocket = null; Socket clientSocket=null; String command; int
	 * replycode; if(state == IDLE) {
	 * printText("ERROR: Please connect to FTP server \r\n"); return; } else
	 * if(state==CONNECTED){ if(PASSIVE==false){ try { //Create the server for
	 * reciving the data connection. serverSocket = new
	 * ServerSocket(0,50,localHost); } catch (IOException e) {
	 * printText("ERROR:Could not create port for listening:  " +
	 * serverSocket.getLocalPort() + ", " + e + "\r\n"); return; } //The FTP
	 * server has to be informed of the port at //which the client is listening.
	 * setDataPort(serverSocket); // Once the data connection server is running
	 * and the // FTP server has been informed of the data connection // port
	 * then we can issue the get command replycode = executeCommand( "RETR",
	 * fileName ); // REPLYCODECHECK // 125, 150 // (110) // 226, 250 // 425,
	 * 426, 451 // 450, 550 // 500, 501, 421, 530
	 * 
	 * if(replycode == POSITIVE_PRELIMINARY_REPLY) { // connect to data port
	 * Socket dataSocket = null; try { dataSocket = serverSocket.accept(); }
	 * catch (IOException e) {
	 * printText("ERROR: Couldn't create data socket.Accept failed: " +
	 * serverSocket.getLocalPort() + ", " + e + "\r\n"); return; } try { //Read
	 * the data from the data socket InputStream
	 * inputstream=dataSocket.getInputStream(); byte datachunk[] = new
	 * byte[1024]; // We use a buffer 1024 int datalength; // Get the current
	 * working directory on the local machine String curDir =
	 * System.getProperty("user.dir"); String newFile = new String(curDir +
	 * File.separatorChar + fileName);
	 * 
	 * RandomAccessFile localfile = new RandomAccessFile(newFile, "rw");
	 * while((datalength = inputstream.read(datachunk)) != -1){
	 * localfile.write(datachunk, 0, datalength);
	 * 
	 * }//end of while printText("\r\n"); // ******Changed in FTP 1.03 Dated
	 * 22/01/98*********** localfile.close(); inputstream.close(); replycode =
	 * checkResponse(); dataSocket.close(); // ********Change
	 * Over********************************* }//end oftry catch (IOException e)
	 * { printText("ERR " + e.toString() + "\r\n"); return; }//end of catch
	 * return; }//End of if else {
	 * printText("ERROR: while trying to download file.\r\n"); try {
	 * serverSocket.close(); } catch (IOException e) {
	 * printText("ERROR: error while closing server socket.\r\n"); return; }
	 * return; }//end of else }//end of if that checks for passive
	 * 
	 * 
	 * 
	 * //This else will be for passive else{ this.passive();
	 * 
	 * try { //Create the server for reciving the data connection. clientSocket
	 * = new Socket(this.hostName,this.passivePort); } catch (IOException e) {
	 * printText("ERROR:Could not create socket for data connection: " + ", " +
	 * e.getMessage()+ "\r\n"); return; } // Once the data connection server is
	 * running and the // FTP server has been informed of the data connection //
	 * port then we can issue the get command replycode = executeCommand(
	 * "RETR", fileName ); // REPLYCODECHECK // 125, 150 // (110) // 226, 250 //
	 * 425, 426, 451 // 450, 550 // 500, 501, 421, 530
	 * 
	 * if(replycode == POSITIVE_PRELIMINARY_REPLY) {
	 * 
	 * try { //Read the data from the data socket InputStream
	 * inputstream=clientSocket.getInputStream(); byte datachunk[] = new
	 * byte[1024]; // We use a buffer 1024 int datalength; // Get the current
	 * working directory on the local machine String curDir =
	 * System.getProperty("user.dir"); String newFile = new String(curDir +
	 * File.separatorChar + fileName);
	 * 
	 * RandomAccessFile localfile = new RandomAccessFile(newFile, "rw");
	 * while((datalength = inputstream.read(datachunk)) != -1){
	 * localfile.write(datachunk, 0, datalength); // printText("#"); }//end of
	 * while printText("\r\n"); localfile.close(); replycode = checkResponse();
	 * inputstream.close();
	 * 
	 * }//end oftry catch (IOException e) { printText("ERROR " + e.toString() +
	 * "\r\n"); return; }//end of catch return; }//End of if else {
	 * printText("ERROR: while trying to download file.\r\n"); try {
	 * clientSocket.close(); } catch (IOException e) {
	 * printText("ERROR: error while closing server socket.\r\n"); return; }
	 * return; }//end of else
	 * 
	 * }//end of else for passive }//end of else if that checks for connected }
	 */
	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param fileName
	 *            java.lang.String
	 */
	public void getFile(java.lang.String fileNameRemote,
			java.lang.String fileNameLocal) {
		ServerSocket serverSocket = null;
		Socket clientSocket = null;
		//String command;
		int replycode;
		if (state == IDLE) {
			printText("ERROR: Please connect to FTP server \r\n");
			return;
		} else if (state == CONNECTED) {
			if (PASSIVE == false) {
				try {
					// Create the server for reciving the data connection.
					serverSocket = new ServerSocket(0, 50, localHost);
				} catch (IOException e) {
					printText("ERROR:Could not create port for listening:  "
							+ serverSocket.getLocalPort() + ", " + e + "\r\n");
					return;
				}
				// The FTP server has to be informed of the port at
				// which the client is listening.
				setDataPort(serverSocket);
				// Once the data connection server is running and the
				// FTP server has been informed of the data connection
				// port then we can issue the get command
				replycode = executeCommand("RETR", fileNameRemote);
				// REPLYCODECHECK
				// 125, 150
				// (110)
				// 226, 250
				// 425, 426, 451
				// 450, 550
				// 500, 501, 421, 530

				if (replycode == POSITIVE_PRELIMINARY_REPLY) {
					// connect to data port
					Socket dataSocket = null;
					try {
						dataSocket = serverSocket.accept();
					} catch (IOException e) {
						printText("ERROR: Couldn't create data socket.Accept failed: "
								+ serverSocket.getLocalPort()
								+ ", "
								+ e
								+ "\r\n");
						return;
					}
					try {
						// Read the data from the data socket
						InputStream inputstream = dataSocket.getInputStream();
						byte datachunk[] = new byte[1024]; // We use a buffer
															// 1024
						int datalength;
						String newFile;
						if (fileNameLocal == null) {
							// Get the current working directory on the local
							// machine
							String curDir = System.getProperty("user.dir");
							newFile = new String(curDir + File.separatorChar
									+ fileNameRemote);
						} else {
							newFile = fileNameLocal;
						}

						RandomAccessFile localfile = new RandomAccessFile(
								newFile, "rw");
						while ((datalength = inputstream.read(datachunk)) != -1) {
							localfile.write(datachunk, 0, datalength);

						}// end of while
						printText("\r\n");
						/****** Changed in FTP 1.03 Dated 22/01/98 ***********/
						localfile.close();
						inputstream.close();
						replycode = checkResponse();
						dataSocket.close();
						/******** Change Over *********************************/
					}// end oftry
					catch (IOException e) {
						printText("ERR " + e.toString() + "\r\n");
						return;
					}// end of catch
					return;
				}// End of if
				else {
					printText("ERROR: while trying to download file.\r\n");
					try {
						serverSocket.close();
					} catch (IOException e) {
						printText("ERROR: error while closing server socket.\r\n");
						return;
					}
					return;
				}// end of else
			}// end of if that checks for passive

			// This else will be for passive
			else {
				this.passive();

				try {
					// Create the server for reciving the data connection.
					clientSocket = new Socket(this.hostName, this.passivePort);
				} catch (IOException e) {
					printText("ERROR:Could not create socket for data connection: "
							+ ", " + e.getMessage() + "\r\n");
					return;
				}
				// Once the data connection server is running and the
				// FTP server has been informed of the data connection
				// port then we can issue the get command
				replycode = executeCommand("RETR", fileNameRemote);
				// REPLYCODECHECK
				// 125, 150
				// (110)
				// 226, 250
				// 425, 426, 451
				// 450, 550
				// 500, 501, 421, 530

				if (replycode == POSITIVE_PRELIMINARY_REPLY) {

					try {
						// Read the data from the data socket
						InputStream inputstream = clientSocket.getInputStream();
						byte datachunk[] = new byte[1024]; // We use a buffer
															// 1024
						int datalength;
						String newFile;
						if (fileNameLocal == null) {
							// Get the current working directory on the local
							// machine
							String curDir = System.getProperty("user.dir");
							newFile = new String(curDir + File.separatorChar
									+ fileNameRemote);
						} else {
							newFile = fileNameLocal;
						}

						RandomAccessFile localfile = new RandomAccessFile(
								newFile, "rw");
						while ((datalength = inputstream.read(datachunk)) != -1) {
							localfile.write(datachunk, 0, datalength);
							// printText("#");
						}// end of while
						printText("\r\n");
						localfile.close();
						replycode = checkResponse();
						inputstream.close();

					}// end oftry
					catch (IOException e) {
						printText("ERROR " + e.toString() + "\r\n");
						return;
					}// end of catch
					return;
				}// End of if
				else {
					printText("ERROR: while trying to download file.\r\n");
					try {
						clientSocket.close();
					} catch (IOException e) {
						printText("ERROR: error while closing server socket.\r\n");
						return;
					}
					return;
				}// end of else

			}// end of else for passive
		}// end of else if that checks for connected
	}

	/**
	 * This method was created by a SmartGuide.
	 */
	public String getRemoteCurrentDir() {
		return this.remoteCurrentDir;
	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @return java.util.Vector
	 */
	public java.util.Vector<FileInfo> getRemoteFileList() {
		return remoteFileList;
	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @return FTPProtocolBean.Protocol
	 */
	/**
	 * BIPIN public static Remote getRemoteProtocol (FTPProtocol parent ) { //if
	 * instance is not null then create a instance and return.
	 * if(instance==null){ instance=new Remote(parent); } return instance; }
	 **/
	/**
	 * This method was created by a SmartGuide.
	 */
	public void getStatus() {
		//String command = null;
		int replycode;
		if (state == CONNECTED) {
			replycode = executeCommand("STAT", null);
			// REPLYCODECHECK
			// 211, 212, 213
			// 450
			// 500, 501, 502, 421
		}// end of outer if
		else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
			return;
		}
		return;
	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param userName
	 *            java.lang.String
	 * @param passwd
	 *            java.lang.String
	 */
	public synchronized void login(java.lang.String userName,
			java.lang.String passwd) {
		int replycode;
		String command;
		if (state == CONNECTED) {

			replycode = executeCommand("USER", userName);

			// REPLYCODECHECK
			// 230
			// 530
			// 500, 502, 421
			// 331, 332

			if (replycode == POSITIVE_INTERMEDIATE_REPLY) {

				command = createCommand("PASS", passwd);
				printText("PASS xxxxxx\r\n");
				controlOutputStream.print(command);
				replycode = checkResponse();

				// REPLYCODECHECK
				// 230
				// 202
				// 530
				// 500, 501, 503, 421
				// 332

				if (replycode == POSITIVE_COMPLETION_REPLY) {
					// This method added on 21/01/98
					// The Client was not working for MainFrame servers
					// hence this code was added
					/*********************************************/
					this.setSystem();
					/*********************************************/

					this.remoteCurrentDir = getCurrentDir();
					parent.fileList(true);
					return;
				}
			}

			// CF -- Sunanda Bera 11, Aug, 1998
			// This code was added to accomodate servers which do not
			// have password verification policy for certain users
			if (replycode == POSITIVE_COMPLETION_REPLY) {
				// This method added on 21/01/98
				// The Client was not working for MainFrame servers
				// hence this code was added
				/*********************************************/
				this.setSystem();
				/*********************************************/

				this.remoteCurrentDir = getCurrentDir();
				parent.fileList(true);
				return;
			}
			// CF
		} else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
			return;
		}

		// replycode = checkResponse();

		return;

	}

	/**
	 * makeDir method comment.
	 */
	public void makeDir(String dirName) {
		//String command;
		int replycode;
		if (state == CONNECTED) {
			replycode = executeCommand("MKD", dirName);
			// REPLYCODECHECK
			// 257
			// 500, 501, 502, 421, 530, 550
		} else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
			return;
		}
	}

	/**
	 * This method was created by a SmartGuide.
	 */
	public void passive() {
		// the command
		String command = null;
		// the reply from server
		String reply = null;
		// reply code from server
		int replycode;

		if (state == CONNECTED) {
			command = createCommand("PASV", null);
			controlOutputStream.print(command);
			printText(command + "\r\n");

			try {
				do {
					reply = controlInputStream.readLine();
					printText(reply + "\r\n");
				}
				// Continue reading till the first three characters
				// are digits followed by blank space. The three
				// digits are reply code from FTP server.
				while (!endOfReply(reply));
			}// end of try
			catch (Exception e) {
				printText("ERROR: Error reading from  the controlconnection!\r\n");
				return;
			}// end of catch

			replycode = (Integer.parseInt(reply.substring(0, 1)));

			// REPLYCODECHECK
			// 227
			// 500, 501, 421, 530

			if (replycode == 2) { // the passive command was successful
				PASSIVE = true;
				// tokenize the command using "," as the token
				StringTokenizer stoken = new StringTokenizer(reply, ",");

				// skip first four tokens that are not required
				for (int i = 0; i < 4; i++) {
					if (!stoken.hasMoreTokens()) {
						printText("ERROR: Error reading from  the controlconnection!\r\n");
						printText("ERROR: Not enough (4) tokens in reply["
								+ reply + "]!\r\n");
						return;
					}
					stoken.nextToken();
				}// end of for
				if (!stoken.hasMoreTokens()) {
					printText("ERROR: Error reading from  the controlconnection!\r\n");
					printText("ERROR: Not enough (5) tokens in reply[" + reply
							+ "]!\r\n");
					return;
				}
				int highOrderPort = Integer.parseInt(stoken.nextToken());
				if (!stoken.hasMoreTokens()) {
					printText("ERROR: Error reading from  the controlconnection!\r\n");
					printText("ERROR: Not enough (6) tokens in reply[" + reply
							+ "]!\r\n");
					return;
				}
				String lowOrder = stoken.nextToken();
				// the reply for ftp server other than Mainframe server
				// ends with ")". But for mainfrmae server there is no
				// trailing ")". hence check for that
				int lowOrderPort;
				// CF -- Sunanda Bera 11 August 1998
				// The prescribed reply is
				// "227 Entering Passive Mode (h1,h2,h3,h4,p1,p2)."
				// Mainframe servers do not put brackets, some omit the "."
				// ftp1.11 and prior versions were configured to accept
				// mainframe replies
				// and prescribed without "." Change made so that prescribed
				// replies can
				// also be accomodated.
				/***
				 * OLD CODE if(lowOrder.endsWith(")")){ //for servers other than
				 * mainframe int index=lowOrder.indexOf(")");
				 * lowOrderPort=Integer.parseInt(lowOrder.substring(0,index)); }
				 * END OF OLD CODE
				 **/
				int index = lowOrder.indexOf(")");
				if (index != -1) {
					// for servers other than mainframe
					lowOrderPort = Integer.parseInt(lowOrder
							.substring(0, index));
				} else {
					// for mainframe server
					lowOrderPort = Integer.parseInt(lowOrder);
				}
				// CF

				passivePort = highOrderPort * 256 + lowOrderPort;

				// set the passive port value

			}// end of if
		}// end of if that checks state
		else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
			return;
		}
		return;
	}

	/**
	 * printText method comment.
	 */
	protected void printText(String text) {
		// Send the string received to the parent bean to be sent back
		// to the User Interface bean

		this.parent.sendMessage(text);

	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param fileName
	 *            java.lang.String
	 */
	public void putFile(java.lang.String localFileName,
			java.lang.String remoteFileName) {
		ServerSocket serverSocket = null;
		Socket clientSocket = null;
		Socket dataSocket = null;
		RandomAccessFile localfile = null;
		OutputStream outputStream;
		String command;
		int replycode;
		int datalength;

		if (state == IDLE) {
			printText("ERROR You are not connected to FTP Server, unable to send file!\r\n");
			return;
		}// end of if
		else if (state == CONNECTED) {
			int idxOfFileSeparator = localFileName
					.lastIndexOf(File.separatorChar);
			if (remoteFileName == null) {
				if (idxOfFileSeparator >= 0)
					remoteFileName = localFileName
							.substring(idxOfFileSeparator + 1);
				else
					remoteFileName = localFileName;
			}
			/********* Changed on 11/02/97 *****************/
			String newFile;
			if (idxOfFileSeparator >= 0)
				newFile = localFileName;
			else {
				String curDir = System.getProperty("user.dir");
				newFile = new String(curDir + File.separatorChar
						+ localFileName);
			}
			// open the local file to read data from
			try {
				localfile = new RandomAccessFile(newFile, "r");
			} catch (Exception e) {
				printText("ERROR: File " + localFileName
						+ " not found on local machine" + "\r\n");
				return;
			}
			if (PASSIVE == false) {// checks for passive
				try {
					// create a new server socket for data connection
					serverSocket = new ServerSocket(0, 50, localHost);
				}// end of try
				catch (IOException e) {
					printText("ERROR:Could not create data connection"
							+ serverSocket.getLocalPort() + ", " + e + "\r\n");
					return;
				}// end of catch
					// Inform the FTP server of the port at which data
					// connection
					// is listening
				setDataPort(serverSocket);
				// Create the command for put using store unique
				replycode = executeCommand("STOR", remoteFileName);
				// REPLYCODECHECK
				// 125, 150
				// (110)
				// 226, 250
				// 425, 426, 451, 551, 552
				// 532, 450, 452, 553
				// 500, 501, 421, 530

				// check whether the command was successful
				if (replycode == POSITIVE_PRELIMINARY_REPLY) {
					// Open a socket from the server socket
					try {
						dataSocket = serverSocket.accept();
					}// end of try
					catch (IOException e) {
						printText("ERROR:Couldn't create data socket Accept failed: "
								+ serverSocket.getLocalPort()
								+ ", "
								+ e
								+ "\r\n");
						return;
					}// end of catch
					try {
						// Open a output stream to write data
						outputStream = dataSocket.getOutputStream();
						// Create a buffer of size 1024
						byte datachunk[] = new byte[1024];
						// Read the current working directory on the local
						// machine
						/*
						 * String curDir = System.getProperty("user.dir");
						 * String newFile = new String(curDir +
						 * File.separatorChar + fileName); // open the local
						 * file to read data from RandomAccessFile localfile =
						 * new RandomAccessFile(newFile, "r");
						 */
						// Note: read returns 0 at EOF (API says -1)
						while ((datalength = localfile.read(datachunk)) > 0) {
							outputStream.write(datachunk, 0, datalength);

						}// end of while
						printText("\r\n");
						// close the local file and socket
						localfile.close();
						outputStream.close();
						dataSocket.close();
						serverSocket.close();
						replycode = checkResponse();
					}// end of try
					catch (IOException e) {
						/********** Changed on 11/02/98 *****************/
						printText("ERROR " + localFileName + " not found. "
								+ "\r\n");
						try {
							dataSocket.close();
							serverSocket.close();
							replycode = checkResponse();
						} catch (Exception ex) {
							printText("ERROR " + ex.getMessage() + "\r\n");
						}

						return;
					}// end of catch
					return;

				}// end of if
				else {
					printText("ERROR while trying to send file to server.\r\n");
					try {
						serverSocket.close();
					}// end of try
					catch (IOException e) {
						printText("ERROR while closing server socket.\r\n");
						return;
					}// end of catch
					return;
				}// end of else if
			}// this ends the check that passive is false

			// ****************PASSIVE=true*******************

			//
			// this part of code that follows is for PASSIVE=true
			else {
				this.passive();// open a new connection
				try {
					// create a new socket for passive data connection
					clientSocket = new Socket(this.hostName, this.passivePort);
				}// end of try
				catch (IOException e) {
					printText("ERROR:Could not create passive data connection"
							+ ", " + e.getMessage() + "\r\n");
					return;
				}// end of catch
					// Create the command for put using store unique
				replycode = executeCommand("STOR", remoteFileName);
				// REPLYCODECHECK
				// 125, 150
				// (110)
				// 226, 250
				// 425, 426, 451, 551, 552
				// 532, 450, 452, 553
				// 500, 501, 421, 530
				// check whether the command was successful
				if (replycode == POSITIVE_PRELIMINARY_REPLY) {
					try {
						// Open a output stream to write data
						outputStream = clientSocket.getOutputStream();
						// Create a buffer of size 1024
						byte datachunk[] = new byte[1024];
						// Read the current working directory on the local
						// machine
						/*
						 * String curDir = System.getProperty("user.dir");
						 * String newFile = new String(curDir +
						 * File.separatorChar + fileName); // open the local
						 * file to read data from RandomAccessFile localfile =
						 * new RandomAccessFile(newFile, "r");
						 */
						// Note: read returns 0 at EOF (API says -1)
						while ((datalength = localfile.read(datachunk)) > 0) {
							outputStream.write(datachunk, 0, datalength);

						}// end of while
						printText("\r\n");
						// close the local file and socket
						localfile.close();
						outputStream.close();
						clientSocket.close();

						replycode = checkResponse();
					}// end of try
					catch (IOException e) {
						printText("ERROR " + localFileName + " not found. "
								+ "\r\n");
						try {
							dataSocket.close();
							serverSocket.close();
							replycode = checkResponse();
						} catch (Exception ex) {
							printText("ERROR " + ex.getMessage() + "\r\n");
						}
						return;
					}// end of catch
					return;

				}// end of if
				else {
					printText("ERROR while trying to send file to server.\r\n");
					try {
						clientSocket.close();
					}// end of try
					catch (IOException e) {
						printText("ERROR while closing passive data socket.\r\n");
						return;
					}// end of catch
					return;
				}// end of else if
			}// end of else that checks for PASSIVE=true

		}// end of else that checks for connected
	}

	/**
	 * rename method comment.
	 */
	public void rename(String oldName, String newName) {
		int replycode;
		//String command = null;
		if (state == CONNECTED) {
			replycode = executeCommand("RNFR", oldName);
			// REPLYCODECHECK
			// 450, 550
			// 500, 501, 502, 421, 530
			// 350

			if (replycode != POSITIVE_INTERMEDIATE_REPLY) {
				replycode = executeCommand("ABOR", null);
				// REPLYCODECHECK
				// 225, 226
				// 500, 501, 502, 421
			} else {
				replycode = executeCommand("RNTO", newName);
				// REPLYCODECHECK
				// 250
				// 532, 553
				// 500, 501, 502, 503, 421, 530
			}
		} else if (state == IDLE) {
			printText("You are not connected to any server \r\n");
		}
	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param serSocket
	 *            java.net.ServerSocket
	 */
	private void setDataPort(java.net.ServerSocket serverSocket) {
		int replycode;
		if (state == CONNECTED) {
			replycode = executeCommand("PORT", calculatePort(serverSocket));
			// REPLYCODECHECK
			// 200
			// 500, 501, 421, 530
		} else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
			return;
		}
		return;
	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param datain
	 *            java.io.DataInputStream
	 * @param fileList
	 *            java.util.Vector
	 * @param serverOS
	 *            java.lang.String
	 */
	private java.util.Vector<FileInfo> setFileListDescription(
			java.io.DataInputStream dataInputStream, String serverOS) {
		Vector<FileInfo> fileList = new Vector<FileInfo>();
		String reply = null;
		boolean finished = false;
		FileInfo fileInfo = null;

		try {
			if (serverOS.equals("VM") || serverOS.equals("MVS")) {
				while (!finished) {
					reply = dataInputStream.readLine();

					if (reply == null) {
						finished = true;
					}// end of if
					else {

						fileInfo = new FileInfo();
						fileInfo.setRemoteDescriptionVM(reply);
						fileList.addElement(fileInfo);

					}// end of outer else
				}// end of while
				return fileList;
			}// end of outer if
			else {
				while (!finished) {
					reply = dataInputStream.readLine();

					if (reply == null) {
						finished = true;
					}// end of if
					else {

						if (reply.startsWith("total")) {
							// First line received on the data
							// connection begins with total and it
							// doesn't need to be processed.
						}// end of if
						else {
							fileInfo = new FileInfo();
							fileInfo.setRemoteDescriptionUNIX(reply);
							fileList.addElement(fileInfo);
						}// end of inner else

					}// end of outer else
				}// end of while
				return fileList;
			}// end of outer else
		} catch (IOException e) {
			printText("ERROR " + e.toString() + "\r\n");
			return fileList;
		}// end of catch

	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param passive
	 *            boolean
	 */
	public void setPassive(boolean passive) {
		PASSIVE = passive;
		return;
	}

	/**
	 * This method was created by a SmartGuide.
	 */
	protected void setSystem() {
		int replycode;
		if (state == CONNECTED) {
			replycode = executeCommand("SYST", null);
			// REPLYCODECHECK
			// 215
			// 500, 501, 502, 421
			if (replycode == POSITIVE_COMPLETION_REPLY) {
				StringTokenizer stoken = new StringTokenizer(parent.getStatus());
				// The first token is reply code which isnot required
				stoken.nextToken();
				// Next token is name of the Server system
				serverOS = stoken.nextToken();
			}// end of inner if
		}// end of outer if
		else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
			return;
		}
		return;
	}

	/**
	 * This method was created by a SmartGuide.
	 * 
	 * @param type
	 *            java.lang.String
	 * @return int
	 */
	public int setType(java.lang.String type) {
		int replycode = -1;
		if (state == CONNECTED) {
			// If the type requested is ASCII
			if (type.equalsIgnoreCase("ASCII")) {

				replycode = executeCommand("TYPE", "A");
			}// end of if
				// If the type requested is binary
			else if (type.equalsIgnoreCase("BINARY")) {
				replycode = executeCommand("TYPE", "I");
			}// end of else if
				// REPLYCODECHECK
				// 200
				// 500, 501, 502, 421, 530
		}// end of outer if
		else if (state == IDLE) {
			printText("Not connected to any FTP server \r\n");
		}
		// Return the reply code for setting the local
		// type property in FtpProtocol' setType method.
		return replycode;
	}

	// CF -- Sunanda Bera 11 August 1998.
	// Change made on ftp1.11
	// A feeble attempt at command factory.
	/**
	 * This method constructs a command string given the command and and the
	 * arguments. Inserts a space between command and arguments and terminates
	 * each command by a <CRLF>.
	 */
	private String createCommand(String commandName, String arguments) {
		String command = ((arguments == null) ? commandName : (commandName
				+ " " + arguments))
				+ "\r\n";

		return command;
	}// end of createCommand

	/**
	 * Execute a command and return the reply code.
	 */
	private int executeCommand(String commandName, String arguments) {
		String command = createCommand(commandName, arguments);
		controlOutputStream.print(command);
		printText(command);
		return checkResponse();
	}
	// CF
}
